async def monitor_job():
    """
    –ú–æ–Ω—ñ—Ç–æ—Ä–∏–Ω–≥ –Ω–æ–≤–∏—Ö –≥—Ä–∞—Ñ—ñ–∫—ñ–≤ –∑ OCR –ø–∞—Ä—Å–∏–Ω–≥–æ–º —ñ –∫–µ—à—É–≤–∞–Ω–Ω—è–º
    """
    try:
        logging.info("Starting monitor job with OCR parsing")

        # –û—Ç—Ä–∏–º—É—î–º–æ –¥–∞–Ω—ñ –∑ —Å–∞–π—Ç—É
        all_data = await parse_hoe_smart()
        if not all_data:
            logging.info("No data parsed from site")
            return

        logging.info(f"Parsed data for dates: {list(all_data.keys())}")

        conn = sqlite3.connect('users.db')
        cursor = conn.cursor()

        # –ó–∞–≤–∞–Ω—Ç–∞–∂—É—î–º–æ –∫–µ—à–æ–≤–∞–Ω—ñ —Ä–æ–∑–∫–ª–∞–¥–∏
        cached_schedules = load_cached_schedules()
        logging.info(f"Loaded cached schedules for dates: {list(cached_schedules.keys())}")

        now = datetime.now()
        current_date_str = now.strftime("%d.%m.%Y")
        updated_dates = []

        for date_key, data in all_data.items():
            try:
                # –ü—Ä–æ–ø—É—Å–∫–∞—î–º–æ –º–∏–Ω—É–ª—ñ –¥–∞—Ç–∏
                try:
                    date_dt = datetime.strptime(date_key, "%d.%m.%Y")
                except ValueError:
                    try:
                        date_dt = datetime.strptime(date_key, "%d.%m.%y")
                        date_dt = date_dt.replace(year=2000 + date_dt.year % 100)
                    except ValueError:
                        continue

                if date_dt.date() < now.date():
                    logging.info(f"Skipping past date {date_key}")
                    continue

                # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ —á–∏ —î –∑–º—ñ–Ω–∏ –≤ –≥—Ä–∞—Ñ—ñ–∫—É
                img_url = data.get('img', '')
                has_image = data.get('has_image', False)
                parsed_list = data.get('list', {})

                # –û—Ç—Ä–∏–º—É—î–º–æ –∫–µ—à–æ–≤–∞–Ω–∏–π —Ä–æ–∑–∫–ª–∞–¥ –¥–ª—è —Ü—ñ—î—ó –¥–∞—Ç–∏
                cached_date_data = cached_schedules.get(date_key, {})

                # –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∏–ø –∑–º—ñ–Ω–∏
                is_new_schedule = date_key not in cached_schedules
                img_changed = cached_date_data.get('img_url', '') != img_url
                has_new_image = has_image and not cached_date_data.get('has_image', False)

                logging.info(f"Checking {date_key}: is_new={is_new_schedule}, img_changed={img_changed}, has_image={has_image}")

                if is_new_schedule or img_changed or has_new_image:
                    logging.info(f"Detected change for {date_key}, parsing with OCR")

                    # –ü–∞—Ä—Å–∏–º–æ –≥—Ä–∞—Ñ—ñ–∫ —á–µ—Ä–µ–∑ OCR
                    if has_image and img_url:
                        ocr_schedules = await parse_schedule_image(img_url)
                        logging.info(f"OCR parsed {len(ocr_schedules)} subqueues for {date_key}")

                        # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –≤ –∫–µ—à
                        for subqueue, schedule_text in ocr_schedules.items():
                            update_cached_schedule(date_key, subqueue, schedule_text, "full")

                        # –ü–æ–∑–Ω–∞—á–∞—î–º–æ —â–æ —î –æ–Ω–æ–≤–ª–µ–Ω–Ω—è
                        cached_schedules[date_key] = {
                            'img_url': img_url,
                            'has_image': True,
                            'last_updated': now.isoformat(),
                            'subqueues': list(ocr_schedules.keys())
                        }

                        updated_dates.append(date_key)

                        # –ì–µ–Ω–µ—Ä—É—î–º–æ –≥–æ–¥–∏–Ω–Ω–∏–∫–∏ –¥–ª—è –≤—Å—ñ—Ö —á–µ—Ä–≥
                        for subqueue in ocr_schedules.keys():
                            schedule_text = ocr_schedules[subqueue]
                            generate_clock_image(subqueue, schedule_text, date_key)
                            logging.info(f"Generated clock for {subqueue} on {date_key}")

                    save_cached_schedules(cached_schedules)

                # –Ø–∫—â–æ —î —Ç–µ–∫—Å—Ç–æ–≤–∏–π –æ–ø–∏—Å –∞–ª–µ –Ω–µ–º–∞—î –∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è - –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î–º–æ —Ç–µ–∫—Å—Ç
                elif parsed_list and not has_image:
                    logging.info(f"Using text schedule for {date_key}")
                    for subqueue, schedule_text in parsed_list.items():
                        normalized_text = normalize_schedule_text(schedule_text)
                        update_cached_schedule(date_key, subqueue, normalized_text, "full")

                        # –ì–µ–Ω–µ—Ä—É—î–º–æ –≥–æ–¥–∏–Ω–Ω–∏–∫
                        generate_clock_image(subqueue, normalized_text, date_key)

                    updated_dates.append(date_key)

            except Exception as e:
                logging.error(f"Error processing date {date_key}: {e}")
                continue

        # –ó–±–µ—Ä—ñ–≥–∞—î–º–æ –æ–Ω–æ–≤–ª–µ–Ω—ñ –∫–µ—à–æ–≤–∞–Ω—ñ —Ä–æ–∑–∫–ª–∞–¥–∏
        cursor.execute('INSERT OR REPLACE INTO settings (key, value) VALUES ("cached_schedules", ?)',
                      (json.dumps(cached_schedules),))
        conn.commit()

        logging.info(f"Updated dates: {updated_dates}")

        # –¢–µ–ø–µ—Ä –æ–±—Ä–æ–±–ª—è—î–º–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –¥–ª—è —Å—å–æ–≥–æ–¥–Ω—ñ —ñ –∑–∞–≤—Ç—Ä–∞
        today_str = now.strftime("%d.%m.%Y")
        tomorrow = now + timedelta(days=1)
        tomorrow_str = tomorrow.strftime("%d.%m.%Y")

        # –û—Ç—Ä–∏–º—É—î–º–æ —Ä–æ–∑–∫–ª–∞–¥–∏ –¥–ª—è —Å–ø–æ–≤—ñ—â–µ–Ω—å
        today_schedules = {}
        tomorrow_schedules = {}

        for date_key in [today_str, tomorrow_str]:
            date_schedules = cached_schedules.get(date_key, {})
            if isinstance(date_schedules, dict) and 'subqueues' in date_schedules:
                # –û—Ç—Ä–∏–º—É—î–º–æ —Ä–æ–∑–∫–ª–∞–¥–∏ –∑ –∫–µ—à—É
                for subqueue in date_schedules['subqueues']:
                    schedule_text = get_schedule_for_date(date_key, subqueue)
                    if schedule_text:
                        if date_key == today_str:
                            today_schedules[subqueue] = schedule_text
                        else:
                            tomorrow_schedules[subqueue] = schedule_text

        logging.info(f"Today schedules: {len(today_schedules)} subqueues")
        logging.info(f"Tomorrow schedules: {len(tomorrow_schedules)} subqueues")

        # –û–±—Ä–æ–±–ª—è—î–º–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è (–∑–∞–ª–∏—à–∞—î–º–æ —ñ—Å–Ω—É—é—á—É –ª–æ–≥—ñ–∫—É –∞–ª–µ –∑ –Ω–æ–≤–∏–º–∏ –¥–∞–Ω–∏–º–∏)
        for sub_q in today_schedules.keys():
            try:
                time_text_today = today_schedules.get(sub_q, "")
                time_text_tomorrow = tomorrow_schedules.get(sub_q, "")

                # –ó–±–∏—Ä–∞—î–º–æ –≤—Å—ñ —ñ–Ω—Ç–µ—Ä–≤–∞–ª–∏ –¥–ª—è —Å—å–æ–≥–æ–¥–Ω—ñ —ñ –∑–∞–≤—Ç—Ä–∞
                combined_intervals = []

                # –Ü–Ω—Ç–µ—Ä–≤–∞–ª–∏ —Å—å–æ–≥–æ–¥–Ω—ñ (–≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω—ñ + –º–æ–∂–ª–∏–≤—ñ)
                intervals_today = parse_schedule_to_intervals(time_text_today)
                for start_hour, end_hour in intervals_today['guaranteed'] + intervals_today['possible']:
                    start_dt = datetime.combine(now.date(), datetime.min.time()) + timedelta(hours=start_hour)
                    end_dt = datetime.combine(now.date(), datetime.min.time()) + timedelta(hours=end_hour)
                    if end_dt <= start_dt:
                        end_dt += timedelta(days=1)
                    combined_intervals.append((start_dt, end_dt))

                # –Ü–Ω—Ç–µ—Ä–≤–∞–ª–∏ –∑–∞–≤—Ç—Ä–∞
                intervals_tomorrow = parse_schedule_to_intervals(time_text_tomorrow)
                for start_hour, end_hour in intervals_tomorrow['guaranteed'] + intervals_tomorrow['possible']:
                    start_dt = datetime.combine(tomorrow.date(), datetime.min.time()) + timedelta(hours=start_hour)
                    end_dt = datetime.combine(tomorrow.date(), datetime.min.time()) + timedelta(hours=end_hour)
                    if end_dt <= start_dt:
                        end_dt += timedelta(days=1)
                    combined_intervals.append((start_dt, end_dt))

                # –ó–Ω–∞—Ö–æ–¥–∏–º–æ —Ç–æ—á–∫–∏ –∑–º—ñ–Ω–∏ –≤ –Ω–∞–π–±–ª–∏–∂—á—ñ 30 —Ö–≤
                t30_dt = now + timedelta(minutes=30)
                user_alerts = {}  # uid -> list of (change_dt, is_shutdown, addr_names, is_possible)

                for start_dt, end_dt in combined_intervals:
                    # –í–∏–∑–Ω–∞—á–∞—î–º–æ —Ç–∏–ø –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è (–≥–∞—Ä–∞–Ω—Ç–æ–≤–∞–Ω–µ —á–∏ –º–æ–∂–ª–∏–≤–µ)
                    is_possible = any(
                        start_dt.hour >= start_hour and end_dt.hour <= end_hour
                        for start_hour, end_hour in intervals_today['possible'] + intervals_tomorrow['possible']
                    )

                    change_points = [(start_dt, True, is_possible), (end_dt, False, is_possible)]
                    for change_dt, is_shutdown, is_possible in change_points:
                        if now < change_dt <= t30_dt:
                            minutes_left = int((change_dt - now).total_seconds() / 60)
                            change_time_str = change_dt.strftime("%H:%M")
                            event_date = change_dt.strftime("%Y-%m-%d")

                            # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ –∑ —Ü—ñ—î—é —á–µ—Ä–≥–æ—é
                            cursor.execute('SELECT user_id, GROUP_CONCAT(name) FROM addresses WHERE subqueue = ? GROUP BY user_id', (sub_q,))
                            users_in_q = cursor.fetchall()
                            for uid, addr_names_str in users_in_q:
                                # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è
                                general_settings = get_user_notification_settings(uid)
                                if not general_settings['notifications_enabled']:
                                    continue

                                addr_list = addr_names_str.split(',')
                                enabled_addrs = []
                                for addr_name in addr_list:
                                    addr_settings = get_user_notification_settings(uid, addr_name.strip())
                                    if addr_settings['notifications_enabled']:
                                        enabled_addrs.append(addr_name.strip())

                                if not enabled_addrs:
                                    continue

                                if uid not in user_alerts:
                                    user_alerts[uid] = []
                                user_alerts[uid].append((change_dt, is_shutdown, enabled_addrs, sub_q, is_possible))

                # –ù–∞–¥—Å–∏–ª–∞—î–º–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞–º
                for uid, alerts in user_alerts.items():
                    # –ì—Ä—É–ø—É—î–º–æ –∑–∞ —á–∞—Å–æ–º
                    time_groups = {}
                    for change_dt, is_shutdown, addrs, subq, is_possible in alerts:
                        key = (change_dt, is_shutdown, is_possible)
                        if key not in time_groups:
                            time_groups[key] = []
                        time_groups[key].extend(addrs)

                    for (change_dt, is_shutdown, is_possible), addr_list in time_groups.items():
                        minutes_left = int((change_dt - now).total_seconds() / 60)
                        change_time_str = change_dt.strftime("%H:%M")
                        event_date = change_dt.strftime("%Y-%m-%d")

                        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≤–∂–µ –Ω–∞–¥—Å–∏–ª–∞–ª–∏
                        cursor.execute('SELECT 1 FROM sent_alerts WHERE user_id=? AND event_time=? AND event_date=?',
                                       (uid, change_time_str, event_date))
                        if cursor.fetchone():
                            continue

                        if is_shutdown:
                            if is_possible:
                                alert_base = f"‚ö†Ô∏è <b>–£–≤–∞–≥–∞! –ú–æ–∂–ª–∏–≤–µ –≤—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —Å–≤—ñ—Ç–ª–∞</b>\n\n–ß–µ—Ä–µ–∑ {minutes_left} —Ö–≤ ({change_time_str}) –º–æ–∂–ª–∏–≤–µ –ø—Ä–∏–ø–∏–Ω–µ–Ω–Ω—è –ø–æ–¥–∞—á—ñ –µ–ª–µ–∫—Ç—Ä–æ–µ–Ω–µ—Ä–≥—ñ—ó"
                            else:
                                alert_base = f"‚ö†Ô∏è <b>–£–≤–∞–≥–∞! –í—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —Å–≤—ñ—Ç–ª–∞</b>\n\n–ß–µ—Ä–µ–∑ {minutes_left} —Ö–≤ ({change_time_str}) –ø–æ–¥–∞—á–∞ –µ–ª–µ–∫—Ç—Ä–æ–µ–Ω–µ—Ä–≥—ñ—ó –±—É–¥–µ <b>–ø—Ä–∏–ø–∏–Ω–µ–Ω–∞</b>"
                        else:
                            if is_possible:
                                alert_base = f"‚úÖ <b>–ú–æ–∂–ª–∏–≤–µ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –µ–ª–µ–∫—Ç—Ä–æ–µ–Ω–µ—Ä–≥—ñ—ó</b>\n\n–ß–µ—Ä–µ–∑ {minutes_left} —Ö–≤ ({change_time_str}) –º–æ–∂–ª–∏–≤–µ –≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –ø–æ–¥–∞—á—ñ –µ–ª–µ–∫—Ç—Ä–æ–µ–Ω–µ—Ä–≥—ñ—ó"
                            else:
                                alert_base = f"‚úÖ <b>–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –µ–ª–µ–∫—Ç—Ä–æ–µ–Ω–µ—Ä–≥—ñ—ó</b>\n\n–ß–µ—Ä–µ–∑ {minutes_left} —Ö–≤ ({change_time_str}) –ø–æ–¥–∞—á–∞ –µ–ª–µ–∫—Ç—Ä–æ–µ–Ω–µ—Ä–≥—ñ—ó –±—É–¥–µ <b>–≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–∞</b>"

                        if len(addr_list) == 1:
                            alert_msg = f"{alert_base} –¥–ª—è –≤–∞—à–æ—ó –∞–¥—Ä–µ—Å–∏ <b>{addr_list[0]}</b>."
                        else:
                            addr_text = ", ".join(addr_list)
                            alert_msg = f"{alert_base} –¥–ª—è –≤–∞—à–∏—Ö –∞–¥—Ä–µ—Å: <b>{addr_text}</b>."

                        try:
                            await bot.send_message(uid, alert_msg, parse_mode="HTML")
                            cursor.execute('INSERT INTO sent_alerts VALUES (?, ?, ?)', (uid, change_time_str, event_date))
                            conn.commit()
                        except Exception as e:
                            logging.error(f"Failed to send alert to {uid}: {e}")
            except Exception as e:
                logging.error(f"Error processing subqueue {sub_q}: {e}")
                continue

        # Clean up old sent alerts (older than today)
        logging.info("Cleaning up old sent_alerts")
        cursor.execute('DELETE FROM sent_alerts WHERE event_date < ?', (now.strftime("%Y-%m-%d"),))
        conn.commit()

        # Delete old clock files for updated dates
        for date_key in updated_dates:
            date_clean = date_key.replace('.', '_')
            for file in os.listdir('clocks'):
                if date_clean in file and file.endswith('.png'):
                    try:
                        os.remove(os.path.join('clocks', file))
                    except:
                        pass

        conn.close()
        logging.info("Monitor job completed successfully")

    except Exception as e:
        logging.error(f"Error in monitor_job: {e}")
        res = cursor.fetchone()
        known_schedules = json.loads(res[0]) if res and res[0] else {}
        logging.info(f"Loaded known_schedules: {list(known_schedules.keys())}")
        
        # Get all users and their addresses
        cursor.execute('SELECT user_id, name, subqueue FROM addresses')
        all_user_addresses = cursor.fetchall()
        
        now = datetime.now()
        current_date_str = now.strftime("%d.%m.%Y")
        short_date = now.strftime("%d.%m.%y")
        
        updated_dates = []
        
        for date_key, data in all_data.items():
            try:
                # Skip past dates - don't send notifications for schedules that have already passed
                try:
                    date_dt = datetime.strptime(date_key, "%d.%m.%Y")
                except ValueError:
                    try:
                        date_dt = datetime.strptime(date_key, "%d.%m.%y")
                        date_dt = date_dt.replace(year=2000 + date_dt.year % 100)
                    except ValueError:
                        continue
                
                if date_dt.date() < now.date():
                    logging.info(f"Skipping past date {date_key}")
                    continue
                
                is_new = date_key not in known_schedules
                has_list_now = bool(data['list'])
                had_list = known_schedules.get(date_key, {}).get('has_list', False)
                old_list_raw = known_schedules.get(date_key, {}).get('list', {})
                old_list = {k: normalize_schedule_text(v) for k, v in old_list_raw.items()}
                new_list = {k: normalize_schedule_text(v) for k, v in data['list'].items()}
                list_changed = old_list != new_list
                img_changed = known_schedules.get(date_key, {}).get('img', '') != data['img']
                
                logging.info(f"Checking {date_key}: is_new={is_new}, list_changed={list_changed}, img_changed={img_changed}, has_list_now={has_list_now}, had_list={had_list}")
                
                if is_new or img_changed or list_changed or (not had_list and has_list_now):
                    logging.info(f"Detected change for {date_key}: is_new={is_new}, list_changed={list_changed}, img_changed={img_changed}, has_list_now={has_list_now}, had_list={had_list}")
                    
                    # This is new or updated
                    updated_dates.append(date_key)
                    
                    # Determine if it's today, tomorrow, or future
                    try:
                        date_dt = datetime.strptime(date_key, "%d.%m.%Y")
                    except ValueError:
                        try:
                            date_dt = datetime.strptime(date_key, "%d.%m.%y")
                            date_dt = date_dt.replace(year=2000 + date_dt.year % 100)
                        except ValueError:
                            continue
                    
                    days_diff = (date_dt.date() - now.date()).days
                    
                    if days_diff == 0:
                        msg_type = "update_today"
                        change_type = "img_updated" if not is_new else "new_schedule"
                    elif days_diff == 1:
                        msg_type = "new_tomorrow" if is_new else "update_tomorrow"
                        change_type = "new_schedule" if is_new else "img_updated"
                    else:
                        msg_type = "new_future" if is_new else "update_future"
                        change_type = "new_schedule" if is_new else "img_updated"
                    
                    # Send notifications to all users (since schedules are in images, we can't filter by subqueue)
                    user_ids = set()
                    for uid, addr_name, subq in all_user_addresses:
                        user_ids.add(uid)
                    
                    for uid in user_ids:
                        try:
                            # Check user notification settings
                            general_settings = get_user_notification_settings(uid)
                            if not general_settings['notifications_enabled']:
                                continue
                            
                            if msg_type in ["new_tomorrow", "new_future"]:
                                if general_settings['new_schedule_enabled']:
                                    caption = f"üÜï <b>–ù–û–í–ò–ô –ì–†–ê–§–Ü–ö!</b>\n\n–ì—Ä–∞—Ñ—ñ–∫ –Ω–∞ {date_key} –≤–∂–µ –¥–æ—Å—Ç—É–ø–Ω–∏–π –Ω–∞ —Å–∞–π—Ç—ñ."
                                    await bot.send_photo(uid, photo=data['img'], caption=caption, parse_mode="HTML")
                                    if not has_list_now:
                                        await bot.send_message(uid, "üìù <b>–ó–≤–µ—Ä–Ω—ñ—Ç—å —É–≤–∞–≥—É:</b> –î–µ—Ç–∞–ª—å–Ω—ñ —Å–ø–∏—Å–∫–∏ –≥–æ–¥–∏–Ω –≤—ñ–¥–∫–ª—é—á–µ–Ω—å –±—É–¥—É—Ç—å —Ä–æ–∑–ø–∏—Å–∞–Ω—ñ —Ç—Ä–æ—Ö–∏ –ø—ñ–∑–Ω—ñ—à–µ (–∑–∞–∑–≤–∏—á–∞–π –ø—Ä–æ—Ç—è–≥–æ–º –≥–æ–¥–∏–Ω–∏).", parse_mode="HTML")
                            elif msg_type == "update_today":
                                if general_settings['schedule_changes_enabled']:
                                    if list_changed and old_list and new_list:
                                        # Show what changed in schedules
                                        changed_subqueues = []
                                        for sq in set(old_list.keys()) | set(new_list.keys()):
                                            old_sched = old_list.get(sq, "")
                                            new_sched = new_list.get(sq, "")
                                            if old_sched != new_sched:
                                                changed_subqueues.append(f"{sq}: {old_sched} ‚Üí {new_sched}")
                                        
                                        if changed_subqueues:
                                            caption = f"üîÑ <b>–ó–ú–Ü–ù–ò –í –ì–†–ê–§–Ü–ö–£!</b>\n\n–ì—Ä–∞—Ñ—ñ–∫ –Ω–∞ {date_key} –±—É–ª–æ –æ–Ω–æ–≤–ª–µ–Ω–æ:\n" + "\n".join(changed_subqueues[:3])  # Limit to 3 changes
                                            await bot.send_photo(uid, photo=data['img'], caption=caption, parse_mode="HTML")
                                        else:
                                            caption = f"üîÑ <b>–û–ù–û–í–õ–ï–ù–ù–Ø –ì–†–ê–§–Ü–ö–ê!</b>\n\n–ì—Ä–∞—Ñ—ñ–∫ –Ω–∞ {date_key} –±—É–ª–æ –æ–Ω–æ–≤–ª–µ–Ω–æ."
                                            await bot.send_photo(uid, photo=data['img'], caption=caption, parse_mode="HTML")
                                    elif not had_list and has_list_now:
                                        # Lists appeared
                                        caption = f"üìù <b>–û–ù–û–í–õ–ï–ù–ù–Ø –ì–†–ê–§–Ü–ö–ê!</b>\n\n–î–µ—Ç–∞–ª—å–Ω—ñ —Å–ø–∏—Å–∫–∏ –≥–æ–¥–∏–Ω –≤—ñ–¥–∫–ª—é—á–µ–Ω—å –Ω–∞ {date_key} —Ç–µ–ø–µ—Ä –¥–æ—Å—Ç—É–ø–Ω—ñ."
                                        await bot.send_photo(uid, photo=data['img'], caption=caption, parse_mode="HTML")
                                    else:
                                        # General update
                                        caption = f"üîÑ <b>–û–ù–û–í–õ–ï–ù–ù–Ø –ì–†–ê–§–Ü–ö–ê!</b>\n\n–ì—Ä–∞—Ñ—ñ–∫ –Ω–∞ {date_key} –±—É–ª–æ –æ–Ω–æ–≤–ª–µ–Ω–æ."
                                        await bot.send_photo(uid, photo=data['img'], caption=caption, parse_mode="HTML")
                            elif msg_type == "update_tomorrow":
                                if general_settings['schedule_changes_enabled']:
                                    if has_list_now and not had_list:
                                        caption = f"üìù <b>–û–ù–û–í–õ–ï–ù–ù–Ø –ì–†–ê–§–Ü–ö–ê!</b>\n\n–î–µ—Ç–∞–ª—å–Ω—ñ —Å–ø–∏—Å–∫–∏ –≥–æ–¥–∏–Ω –≤—ñ–¥–∫–ª—é—á–µ–Ω—å –Ω–∞ {date_key} —Ç–µ–ø–µ—Ä –¥–æ—Å—Ç—É–ø–Ω—ñ."
                                        await bot.send_photo(uid, photo=data['img'], caption=caption, parse_mode="HTML")
                        except Exception as e:
                            logging.error(f"Failed to send notification to {uid}: {e}")
                        await asyncio.sleep(0.05)
                    
                    # Update known
                    known_schedules[date_key] = {
                        'img': data['img'],
                        'list': data['list'],
                        'has_list': has_list_now,
                        'raw_date': data['raw_date']
                    }
                else:
                    # No change, but ensure it's stored
                    if date_key not in known_schedules:
                        known_schedules[date_key] = {
                            'img': data['img'],
                            'list': data['list'],
                            'has_list': has_list_now,
                            'raw_date': data['raw_date']
                        }
            except Exception as e:
                logging.error(f"Error processing date {date_key}: {e}")
                continue
        
        # Clean up old schedules (keep only current and future dates from the site)
        current_keys = set(all_data.keys())
        future_dates = set()
        for k in known_schedules.keys():
            try:
                dt = datetime.strptime(k, "%d.%m.%Y")
                if dt.date() >= now.date():
                    future_dates.add(k)
            except ValueError:
                pass
        known_schedules = {k: v for k, v in known_schedules.items() if k in current_keys or k in future_dates}
        logging.info(f"After cleanup, known_schedules: {list(known_schedules.keys())}")
        
        # Save updated known_schedules
        logging.info("Saving known_schedules")
        cursor.execute('INSERT OR REPLACE INTO settings (key, value) VALUES ("known_schedules", ?)', (json.dumps(known_schedules),))
        conn.commit()
        
        # Now do the 30-min alerts
        data_today = all_data.get(current_date_str) or all_data.get(short_date)
        if not data_today or not data_today['list']: 
            conn.close()
            return

        schedules_today = data_today['list']
        
        tomorrow_dt = now + timedelta(days=1)
        tomorrow_str = tomorrow_dt.strftime("%d.%m.%Y")
        tomorrow_short = tomorrow_dt.strftime("%d.%m.%y")
        data_tomorrow = all_data.get(tomorrow_str) or all_data.get(tomorrow_short)
        schedules_tomorrow = data_tomorrow['list'] if data_tomorrow else {}

        for sub_q in schedules_today.keys():
            try:
                time_text_today = schedules_today.get(sub_q, "")
                time_text_tomorrow = schedules_tomorrow.get(sub_q, "")

                # –ó–±–∏—Ä–∞—î–º–æ –≤—Å—ñ —ñ–Ω—Ç–µ—Ä–≤–∞–ª–∏ –¥–ª—è —Å—å–æ–≥–æ–¥–Ω—ñ —ñ –∑–∞–≤—Ç—Ä–∞
                combined_intervals = []
                
                # –Ü–Ω—Ç–µ—Ä–≤–∞–ª–∏ —Å—å–æ–≥–æ–¥–Ω—ñ
                intervals_today = re.findall(r"(\d{2}:\d{2})[‚Äì\-\‚Äî\‚àí](\d{2}:\d{2})", time_text_today.replace("–∑ ", "").replace(" –¥–æ ", "-"))
                for start, end in intervals_today:
                    start_dt = datetime.combine(now.date(), datetime.strptime(start, "%H:%M").time())
                    if end == '24:00':
                        end_dt = datetime.combine((now + timedelta(days=1)).date(), datetime.strptime('00:00', "%H:%M").time())
                    else:
                        end_dt = datetime.combine(now.date(), datetime.strptime(end, "%H:%M").time())
                    combined_intervals.append((start_dt, end_dt))
                
                # –Ü–Ω—Ç–µ—Ä–≤–∞–ª–∏ –∑–∞–≤—Ç—Ä–∞
                intervals_tomorrow = re.findall(r"(\d{2}:\d{2})[‚Äì\-\‚Äî\‚àí](\d{2}:\d{2})", time_text_tomorrow.replace("–∑ ", "").replace(" –¥–æ ", "-"))
                for start, end in intervals_tomorrow:
                    start_dt = datetime.combine(tomorrow_dt.date(), datetime.strptime(start, "%H:%M").time())
                    if end == '24:00':
                        end_dt = datetime.combine((tomorrow_dt + timedelta(days=1)).date(), datetime.strptime('00:00', "%H:%M").time())
                    else:
                        end_dt = datetime.combine(tomorrow_dt.date(), datetime.strptime(end, "%H:%M").time())
                    combined_intervals.append((start_dt, end_dt))
                
                # –ó–Ω–∞—Ö–æ–¥–∏–º–æ —Ç–æ—á–∫–∏ –∑–º—ñ–Ω–∏ –≤ –Ω–∞–π–±–ª–∏–∂—á—ñ 30 —Ö–≤
                t30_dt = now + timedelta(minutes=30)
                user_alerts = {}  # uid -> list of (change_dt, is_shutdown, addr_names)
                
                for start_dt, end_dt in combined_intervals:
                    change_points = [(start_dt, True), (end_dt, False)]  # True = shutdown, False = restore
                    for change_dt, is_shutdown in change_points:
                        if now < change_dt <= t30_dt:
                            minutes_left = int((change_dt - now).total_seconds() / 60)
                            change_time_str = change_dt.strftime("%H:%M")
                            event_date = change_dt.strftime("%Y-%m-%d")
                            
                            # –ó–Ω–∞—Ö–æ–¥–∏–º–æ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á—ñ–≤ –∑ —Ü—ñ—î—é —á–µ—Ä–≥–æ—é
                            cursor.execute('SELECT user_id, GROUP_CONCAT(name) FROM addresses WHERE subqueue = ? GROUP BY user_id', (sub_q,))
                            users_in_q = cursor.fetchall()
                            for uid, addr_names_str in users_in_q:
                                # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è
                                general_settings = get_user_notification_settings(uid)
                                if not general_settings['notifications_enabled']:
                                    continue
                                
                                addr_list = addr_names_str.split(',')
                                # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ –Ω–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è –¥–ª—è –∫–æ–∂–Ω–æ—ó –∞–¥—Ä–µ—Å–∏
                                enabled_addrs = []
                                for addr_name in addr_list:
                                    addr_settings = get_user_notification_settings(uid, addr_name.strip())
                                    if addr_settings['notifications_enabled']:
                                        enabled_addrs.append(addr_name.strip())
                                
                                if not enabled_addrs:
                                    continue
                                
                                # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≤–∂–µ –Ω–∞–¥—Å–∏–ª–∞–ª–∏ - REMOVED HERE, moved to after grouping
                                # cursor.execute('SELECT 1 FROM sent_alerts WHERE user_id=? AND event_time=? AND event_date=?', 
                                #                (uid, change_time_str, event_date))
                                # if cursor.fetchone():
                                #     continue
                                
                                if uid not in user_alerts:
                                    user_alerts[uid] = []
                                user_alerts[uid].append((change_dt, is_shutdown, enabled_addrs, sub_q))
                
                # –ù–∞–¥—Å–∏–ª–∞—î–º–æ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –∫–æ—Ä–∏—Å—Ç—É–≤–∞—á–∞–º
                for uid, alerts in user_alerts.items():
                    # –ì—Ä—É–ø—É—î–º–æ –∑–∞ —á–∞—Å–æ–º
                    time_groups = {}
                    for change_dt, is_shutdown, addrs, subq in alerts:
                        key = (change_dt, is_shutdown)
                        if key not in time_groups:
                            time_groups[key] = []
                        time_groups[key].extend(addrs)
                    
                    for (change_dt, is_shutdown), addr_list in time_groups.items():
                        minutes_left = int((change_dt - now).total_seconds() / 60)
                        change_time_str = change_dt.strftime("%H:%M")
                        event_date = change_dt.strftime("%Y-%m-%d")
                        
                        if is_shutdown:
                            alert_base = f"‚ö†Ô∏è <b>–£–≤–∞–≥–∞! –í—ñ–¥–∫–ª—é—á–µ–Ω–Ω—è —Å–≤—ñ—Ç–ª–∞</b>\n\n–ß–µ—Ä–µ–∑ {minutes_left} —Ö–≤ ({change_time_str}) –ø–æ–¥–∞—á–∞ –µ–ª–µ–∫—Ç—Ä–æ–µ–Ω–µ—Ä–≥—ñ—ó –±—É–¥–µ <b>–ø—Ä–∏–ø–∏–Ω–µ–Ω–∞</b>"
                        else:
                            alert_base = f"‚úÖ <b>–í—ñ–¥–Ω–æ–≤–ª–µ–Ω–Ω—è –µ–ª–µ–∫—Ç—Ä–æ–µ–Ω–µ—Ä–≥—ñ—ó</b>\n\n–ß–µ—Ä–µ–∑ {minutes_left} —Ö–≤ ({change_time_str}) –ø–æ–¥–∞—á–∞ –µ–ª–µ–∫—Ç—Ä–æ–µ–Ω–µ—Ä–≥—ñ—ó –±—É–¥–µ <b>–≤—ñ–¥–Ω–æ–≤–ª–µ–Ω–∞</b>"
                        
                        if len(addr_list) == 1:
                            alert_msg = f"{alert_base} –¥–ª—è –≤–∞—à–æ—ó –∞–¥—Ä–µ—Å–∏ <b>{addr_list[0]}</b>."
                        else:
                            addr_text = ", ".join(addr_list)
                            alert_msg = f"{alert_base} –¥–ª—è –≤–∞—à–∏—Ö –∞–¥—Ä–µ—Å: <b>{addr_text}</b>."
                        
                        # –ü–µ—Ä–µ–≤—ñ—Ä—è—î–º–æ, —á–∏ –≤–∂–µ –Ω–∞–¥—Å–∏–ª–∞–ª–∏ –¥–ª—è —Ü—å–æ–≥–æ —á–∞—Å—É
                        cursor.execute('SELECT 1 FROM sent_alerts WHERE user_id=? AND event_time=? AND event_date=?', 
                                       (uid, change_time_str, event_date))
                        if cursor.fetchone():
                            continue  # –í–∂–µ –Ω–∞–¥—Å–∏–ª–∞–ª–∏ —Å–ø–æ–≤—ñ—â–µ–Ω–Ω—è –¥–ª—è —Ü—å–æ–≥–æ —á–∞—Å—É
                        
                        try:
                            await bot.send_message(uid, alert_msg, parse_mode="HTML")
                            cursor.execute('INSERT INTO sent_alerts VALUES (?, ?, ?)', (uid, change_time_str, event_date))
                            conn.commit()
                        except Exception as e:
                            logging.error(f"Failed to send alert to {uid}: {e}")
            except Exception as e:
                logging.error(f"Error processing subqueue {sub_q}: {e}")
                continue
        
        # Clean up old sent alerts (older than today)
        logging.info("Cleaning up old sent_alerts")
        cursor.execute('DELETE FROM sent_alerts WHERE event_date < ?', (now.strftime("%Y-%m-%d"),))
        conn.commit()
        
        # Delete old clock files for updated dates
        for date_key in updated_dates:
            date_clean = date_key.replace('.', '_')
            for file in os.listdir('clocks'):
                if date_clean in file and file.endswith('.png'):
                    try:
                        os.remove(os.path.join('clocks', file))
                    except:
                        pass
        
        conn.close()
    except Exception as e:
        logging.error(f"Error in monitor_job: {e}")

